#!/usr/bin/python

import sys
import subprocess
import random
import time
import math

class Test:
        def __init__(self, command, helptxt):
                self.command = command
                self.helptxt = helptxt

flags = ['-s', '-p', '-r']
tests_lookup = {
        'network'    : Test('cd ./network_test; ./run_network_test.sh', """
    Uses wpa_supplicant and dhclient to connect to network, then uses ping and wget to stress-test.
    This test can be run without arguments (it will look for a wpa configuration in network_test/),
    with a file argument for the wpa configuration (relative paths must be relative to network_test/),
    or with network name and passphrase as arguments.

    e.g. $ ./run_tests.py -s network
         $ ./run_tests.py -s network [ wpa.conf ]
         $ ./run_tests.py -s network [ my_network_name my_network_passphrase ]
"""),
        'vpu'        : Test('cd ./vpu_test; ./run_vpu_test.sh',"""
    First runs VPU Decoder tests, playing files in vpu_test/clips/ and
    generating debug information for the gstreamer pipelins in dots/ and graphs/,
    then runs VPU encoder tests, transcoding videos in network_test/clips to supported formats
    and comparing hashes of resulting videos to those generated by the same pipeline on an i.MX51 Smartbook
    This test is not run with arguments.

    e.g. $ ./run_tests.py -s vpu
"""),
        'vpu_encoder': Test('cd ./vpu_test; ./run_vpu_encoder_tests.sh',"""
    Runs just the VPU encoder tests, transcoding videos in network_test/clips to supported formats
    and comparing hashes of resulting videos to those generated by the same pipeline on an i.MX51 Smartbook
    This test is not run with arguments.

    e.g. $ ./run_tests.py -s vpu_encoder
"""),
        'vpu_decoder': Test('cd ./vpu_test; ./run_vpu_decoder_tests.sh', """
    Just runs VPU Decoder tests, playing files in vpu_test/clips/ and
    generating debug information for the gstreamer pipelins in dots/ and graphs/.
    This test is run without arguments

    e.g. $ ./run_tests.py -s vpu_decoder
"""),
        'gpu'        : Test('cd ./gpu_test; ./run_gpu_test.sh',"""
    Runs OpenVP and Open GLES1&2 AMD graphics demos for Freescale i.MX processors.
    Optionally takes two arguments specifying how many frames of the tests to render
    and how many instances of each available test to launch concurrently
    (default is 1000 frames and 4 instances).

    e.g. $ ./run_tests.py -s gpu
         $ ./run_tests.py -s gpu [ 300 8 ]
"""),
        'memory_device' : Test('cd ./memory_device_test; ./run_memory_device_test.sh',"""
    Tests the memory device (NAND, MMC, PATA, etc) mounted to the root file system.
    This test includes searching for bad blocks, writing ~1GiB of data and comparing output to
    pre-created hash value, and benchmarking read/write speeds of the device.

    This test is run without arguments.

    e.g. $ ./run_tests.py -s memory_device
""")
}
tests = tests_lookup.keys() # ['network', 'vpu', 'vpu_encoder', 'gpu', 'filesystem']

def usage():
        tests_str = ""
        for test in tests:
                tests_str = tests_str + test + " "

        print "usage:" , sys.argv[0] , """< -<spr> <test <[ <args...> ]>+ >* >* <--duration TIME>+
    i.e. specify 0 or more times how (sequential, parallel, or random) 
    to run a given list of tests:""" , tests_str
        print ""
        print """    Each test can be optionally followed by command line arguments 
    surrounded by [  ] (whitespace is important!)"""
        print ""
	print "    e.g. '$ " , sys.argv[0] , """-p gpu [ 100 2 ] vpu -r memory_device network [ 1200 my_network_ssid passphrase ]' 
    would run the gpu and vpu tests in parallel (running the gpu tests for only 100 frames, 2 copies of each test), 
    and then run the network and memory tests sequentially in random order
    (running the network test for no shorter than 1200 seconds on the given network and passphrase)"""
	print ""
	print """    Sets of tests can also be repeated for an arbitrary duration
    by following the tests with "--duration TIME". If TIME >= 0 
    the tests will run for no less than TIME seconds. If TIME < 0, the tests
    will be run forever."""
	print ""
	print """    Finally, you can also use --help <test...> to get more information about a specific test or tests
    (--help must be the first argument encountered. If it is, no tests will be run)"""

# print usage if run with no arguments
if len(sys.argv) == 1: # nothing to run
        usage()
        exit()

# test for "help" first
if sys.argv[1] == '--help':
        if len(sys.argv) == 2: # print usage if run with no tests
                usage()
        else:
                for test in sys.argv[2:]:
                        if test in tests:
                                print test , ":" , tests_lookup[test].helptxt
                        else:
                                print test , ": ERROR: Test not found."
                                print ""
                                usage()
        exit()

# because Python's append isn't sane
# edit: ok, because python's *lists* aren't sane.
# append by value (shallow) rather than reference
def append_list_sane(xs, ys):
        copy = []
        for y in ys:
                copy.append(y)
        xs.append(copy)

# requires `block' conforms to usage
# takes the first argument (flag) and determines how to execute the remaining (tests)
def exec_test_block(block):
        if block[0] == '-s': # sequential
                for test in block[1:]:
                        subprocess.call(test, shell=True)
        elif block[0] == '-r': # random
                tests = block[1:]
                random.shuffle(tests)
                for test in tests:
                        subprocess.call(test, shell=True)
        elif block[0] == '-p': # parallel
                procs = []
                for test in block[1:]:
                        procs.append(subprocess.Popen(test, shell=True))
                for proc in procs:
                        proc.wait()
        else:
                print "Debug message: a execution flag of '" , block[0] , "' here should be impossible'"

# list of tests to exec following a single flag. way to exec is first arg
test_block = []
# all test blocks encountered in command line args
all_test_blocks = []

# guarantee duration is always set
if not (sys.argv[-2] == '--duration'):
        sys.argv = sys.argv + ['--duration', '0']

if 31536000000

# Argument parsing (minus help) as a state table of a Finite State Automaton
#       | -word (flag)          | word (arg or test)    | () (argument_delimit)
#------------------------------------------------------------------------
# INIT: | start new test block  | Error                 | Error                 |
#       |new state: TESTS       |                       |                       |
#------------------------------------------------------------------------
# TESTS:| start new test block  | append to test block  | no action
#       |new state: TESTS       | new state: TESTS      | new state: ARGS
#------------------------------------------------------------------------
# ARGS: | append to prev test   | append to prev. test  | no action
#       | new state: ARGS       | new state: ARGS       | new state: TESTS
#------------------------------------------------------------------------

state="INIT"
for arg in sys.argv[1:-2]:
        if state=="INIT": # looking for a flag
                if not (arg in flags): # bad flag
                        print "Error:" , arg , "is not a valid flag!"
                        usage()
                        exit(1)
                else:
                        test_block.append(arg) # action
                        state="TESTS" # transition
        elif state=="TESTS":
                if arg in tests:
                        test_block.append(tests_lookup[arg].command)  # action
                        # state="TESTS"         # transition
                elif arg in flags:
                        append_list_sane(all_test_blocks, test_block) # one whole test block
                        test_block = [arg]      # action(s)
                        # state = "TESTS"       # transition
                elif arg == '[':
                        state = "ARGS"          # transition (no action)
                else:
                        print "Error:" , arg , "is not a valid test or flag"
			usage()
			exit(1)
        elif state=="ARGS":
                if arg == ']':
                        state="TESTS"           # transition (no action)
                else:
                        test_block[-1] = test_block[-1] + " " + arg

#cleanup
if state=="ARGS":
        print sys.argv[0] , "ERROR: Did not finish parsing args for last test before end of arguments!"
        exit(1)

append_list_sane(all_test_blocks, test_block)

start_time = time.time()
duration = int(sys.argv[-1])

# because python doesn't have do-while loops! D:< what kind of imperative language
# doesn't have do-while loops? Even the stupid imperative subset of J has do-while loops!
while True:
        for block in all_test_blocks:
                exec_test_block(block)
        if math.abs(duration) < (time.time() - start_time) * math.signum(duration):
                break
