#!/usr/bin/python

import sys
import subprocess
import random

class Test:
        def __init__(self, command, helptxt):
                self.command = command
                self.helptxt = helptxt

flags = ['-s', '-p', 'r']
tests_lookup = {
        'network'    : Test('cd ./network_test; ./run_network_test.sh', """
    Uses wpa_supplicant and dhclient to connect to network, then uses ping and wget to stress-test.
    This test can be run without arguments (it will look for a wpa configuration in network_test/),
    with a file argument for the wpa configuration (relative paths must be relative to network_test/),
    or with network name and passphrase as arguments.

    e.g. $ ./run_tests.py -s network
         $ ./run_tests.py -s network [ wpa.conf ]
         $ ./run_tests.py -s network [ my_network_name my_network_passphrase ]
"""),
        'vpu'        : Test('cd ./vpu_test; ./run_vpu_test.sh',"""
    First runs VPU Decoder tests, playing files in vpu_test/clips/ and
    generating debug information for the gstreamer pipelins in dots/ and graphs/,
    then runs VPU encoder tests, transcoding videos in network_test/clips to supported formats
    and comparing hashes of resulting videos to those generated by the same pipeline on an i.MX51 Smartbook
    This test is not run with arguments.

    e.g. $ ./run_tests.py -s vpu
"""),
        'vpu_encoder': Test('cd ./vpu_test; ./run_vpu_encoder_tests.sh',"""
    Runs just the VPU encoder tests, transcoding videos in network_test/clips to supported formats
    and comparing hashes of resulting videos to those generated by the same pipeline on an i.MX51 Smartbook
    This test is not run with arguments.

    e.g. $ ./run_tests.py -s vpu_encoder
"""),
        'vpu_decoder': Test('cd ./vpu_test; ./run_vpu_decoder_tests.sh', """
    Just runs VPU Decoder tests, playing files in vpu_test/clips/ and
    generating debug information for the gstreamer pipelins in dots/ and graphs/.
    This test is not run with arguments.

    e.g. $ ./run_tests.py -s vpu_decoder
"""),
        'gpu'        : Test('cd ./gpu_test; ./run_gpu_test.sh',"""
    Runs OpenVP and Open GLES1&2 AMD graphics demos for Freescale i.MX processors.
    Optionally takes two arguments specifying how many frames of the tests to render
    and how many instances of each available test to launch concurrently
    (default is 1000 frames and 4 instances).

    e.g. $ ./run_tests.py -s gpu
         $ ./run_tests.py -s gpu [ 300 8 ]
"""),
        'memory_device' : Test('cd ./memory_device_test; ./run_memory_device_test.sh',"""
    Tests a memory device for bad blocks, mounts device filesystem to ./memory_device_test/mount_point
    and writes on it ~1GiB of data, compares result to pre-generated hash of data,
    then benchmarks read/write speeds of device.
    The device to test is set by argument.
    By default this device is the 3rd filesystem partition on an SD card (/dev/mmcblk0p3).

    e.g. $ ./run_tests.py -s filesystem
         $ ./run_tests.py -s filesystem [ /dev/mmcblk0p3 ]
""")
}
tests = tests_lookup.keys() # ['network', 'vpu', 'vpu_encoder', 'gpu', 'filesystem']

def usage():
        print "usage:" , sys.argv[0] , """<-<spr> <test [ <args...> ]>* >*
    i.e. specify 0 or more times how (sequential, parallel, or random) 
    to run a given list of tests. """ , tests
        print ""
        print """    Each test can be optionally followed by command line arguments 
    surrounded by [  ] (whitespace is important!)"""
        print ""
	print "    e.g. '$ " , sys.argv[0] , """-p gpu [ 100 ] vpu -r network memory [ /dev/mmcblk0p2 ]' 
    would run the gpu and vpu tests in parallel (running the gpu tests for only 100 frames), 
    and then run the network and memory tests sequentially in random order
    (with read, write, and performance tests on /dev/mmcblk0p2)"""
	print ""
	print """    Sets of tests can also be repeated for an arbitrary duration
    by following the tests with "--duration <time>", in which case
    the tests will run for no less than <time> seconds."""
	print ""
	print """    Finally, you can also use --help <test...> to get more information about a specific test or tests
    (--help must be the first argument encountered. If it is, no tests will be run)"""

# print usage if run with no arguments
if len(sys.argv) == 1: # nothing to run
        usage()
        exit()

# test for "help" first
if sys.argv[1] == '--help':
        if len(sys.argv) == 2: # print usage if run with no tests
                usage()
        else:
                for test in sys.argv[2:]:
                        if test in tests:
                                print test , ":" , tests_lookup[test].helptxt
                        else:
                                print test , ": ERROR: Test not found."
                                print ""
                                usage()
        exit()

# because Python's append isn't sane
# edit: ok, because python's *lists* aren't sane.
# append by value (shallow) rather than reference
def append_list_sane(xs, ys):
        copy = []
        for y in ys:
                copy.append(y)
        xs.append(copy)

# requires `block' conforms to usage
# takes the first argument (flag) and determines how to execute the remaining (tests)
def exec_test_block(block):
        if block[0] == '-s': # sequential
                for test in block[1:]:
                        subprocess.call(test, shell=True)
        elif block[0] == '-r':
                tests = block[1:]
                random.shuffle(tests)
                for test in tests:
                        subprocess.call(test, shell=True)
        elif block[0] == '-p':
                procs = []
                for test in block[1:]:
                        procs.append(subprocess.Popen(test, shell=True))
                for proc in procs:
                        proc.wait()
        else:
                print "Debug message: a execution flag of '" , block[0] , "' here should be impossible'"

# list of tests to exec following a single flag. way to exec is first arg
test_block = []
# all test blocks encountered in command line args
all_test_blocks = []

# guarantee duration is always set
if not (sys.argv[-2] == '--duration'):
        sys.argv = sys.argv + ['--duration', '0']

# Argument parsing (minus help) as a state table of a Finite State Automaton
#       | -word (flag)          | word (arg or test)    | () (argument_delimit)
#------------------------------------------------------------------------
# INIT: | start new test block  | Error                 | Error                 |
#       |new state: TESTS       |                       |                       |
#------------------------------------------------------------------------
# TESTS:| start new test block  | append to test block  | no action
#       |new state: TESTS       | new state: TESTS      | new state: ARGS
#------------------------------------------------------------------------
# ARGS: | append to prev test   | append to prev. test  | no action
#       | new state: ARGS       | new state: ARGS       | new state: TESTS
#------------------------------------------------------------------------

state="INIT"
for arg in sys.argv[1:-2]:
        if state=="INIT": # looking for a flag
                if not (arg in flags): # bad flag
                        print "Error:" , arg , "is not a valid flag!"
                        usage()
                        exit(1)
                else:
                        test_block.append(arg) # action
                        state="TESTS" # transition
        elif state=="TESTS":
                if arg in tests:
                        test_block.append(tests_lookup[arg].command)  # action
                        # state="TESTS"         # transition
                elif arg in flags:
                        append_list_sane(all_test_blocks, test_block) # one whole test block
                        test_block = [arg]      # action(s)
                        # state = "TESTS"       # transition
                elif arg == '[':
                        state = "ARGS"          # transition (no action)
                else:
                        print "Error:" , arg , "is not a valid test or flag"
        elif state=="ARGS":
                if arg == ']':
                        state="TESTS"           # transition (no action)
                else:
                        test_block[-1] = test_block[-1] + " " + arg

#cleanup
if state=="ARGS":
        print sys.argv[0] , "ERROR: Did not finish parsing args for last test before end of arguments!"
        exit(1)

append_list_sane(all_test_blocks, test_block)

print sys.argv[1:-2]

for block in all_test_blocks:
        exec_test_block(block)
